<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Understanding Core.Command and Cmdliner - Fairyland OCaml</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../SUMMARY.html">Summary</a></li><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><a href="../libraries/hashcons.html">Understanding Hashcons</a></li><li class="chapter-item expanded affix "><a href="../core/container-elements.html">What are [@@deriving compare, sexp_of, hash] for?</a></li><li class="chapter-item expanded affix "><a href="../internals/polymorphic-compare.html">What is polymorphic compare?</a></li><li class="chapter-item expanded affix "><a href="../libraries/argparse.html" class="active">Understanding Core.Command and Cmdliner</a></li><li class="chapter-item expanded affix "><a href="../core/maps-and-hashtables.html">Understanding Data Collections in Core</a></li><li class="chapter-item expanded affix "><div>Using Hashcons</div></li><li class="chapter-item expanded affix "><div>Understanding Fix</div></li><li class="chapter-item expanded affix "><div>Using Fix</div></li><li class="chapter-item expanded affix "><div>Understanding Ocamlgraph</div></li><li class="chapter-item expanded affix "><div>Profiling</div></li><li class="chapter-item expanded affix "><div>Deriving print</div></li><li class="chapter-item expanded affix "><div>Understanding type format6</div></li><li class="chapter-item expanded affix "><div>Understanding module Format</div></li><li class="chapter-item expanded affix "><div>Fixed point</div></li><li class="chapter-item expanded affix "><div>Contravariant</div></li><li class="chapter-item expanded affix "><div>Typeclassopedia</div></li><li class="chapter-item expanded affix "><div>OCaml source reading</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fairyland OCaml</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="command-line-argparse"><a class="header" href="#command-line-argparse">Command-line Argparse</a></h1>
<p>Unlike OCaml which itself is straightforward, command-line parse libraries e.g. <code>Core.Command</code> and <code>Cmdliner</code> in OCaml is notoriously difficult to understand and use. The tension may come from sometime people requires a quick solution, while both these libraries are shipping concepts and tools for a full-feathered tool. This post aims to provide alternative tutorials for them. Their official tutorials are at <a href="https://dev.realworldocaml.org/command-line-parsing.html">RWO/Command-Line Parsing</a> and <a href="https://erratique.ch/software/cmdliner/doc/tutorial.html">cmdliner/tutorial</a>. OCaml also has build-in <code>Sys.argv</code> and standard library <code>Arg</code> module (<a href="https://ocaml.org/docs/cli-arguments">tutorial</a>).</p>
<h2 id="what-are-the-driver-functions"><a class="header" href="#what-are-the-driver-functions">What are the Driver Functions?</a></h2>
<p>The first myth to break is they provide driver functions taking raw string of command-line and returning a parsing result. No!</p>
<p><code>Core.Command</code> doesn't provide any driver functions at all. After all, <code>Core.Command</code> helps to build a <code>Command.t</code> which specifies:</p>
<ul>
<li>Step 2: how to parse command-line and get the parsed result</li>
<li>Step 3: how to handle parsed result (and return a <code>unit</code>)</li>
</ul>
<p>The driver function <code>Core.Command.run</code> , in <code>core_unix.command_unix</code>, takes the <code>Core.Command.t</code> and start the work:</p>
<ul>
<li>Step 1: take the commend-line <code>Sys.argv</code> and perform step 2 &amp; 3.</li>
</ul>
<p><code>Cmdliner</code> has a variant of driver functions e.g. <code>Cmdliner.Cmd.eval</code> like the above step 1. They each takes a <code>Cmdliner.Cmd.t</code> like the above step 2 &amp; 3 and returns a standard error code.</p>
<p>⚠️Warning: Since I don't understand the motivation of this design, I usually hack the driver functions and get the parsed result back via a mutable reference.</p>
<h2 id="how-to-parse"><a class="header" href="#how-to-parse">How to Parse?</a></h2>
<p>Both <code>Core.Command</code> and <code>Cmdliner</code> have two-layered compositional primitive functions</p>
<p>The inner layer for <code>Core.Command</code> is a compositional <code>Core.Command.Param.t</code> to compose single key-value parsing. e.g. a argparser for <code>-a=1 -b=t</code> is composed from a argparser for <code>-a=1</code> and a argparser <code>-b=t</code>. The inner layer for <code>Cmdliner</code> is a compositional <code>Cmdliner.Term.t</code>.</p>
<p>The inner layer data are wrapped into outer layer data <code>Core.Command.t</code> or <code>Cmdliner.Cmd.t</code> via packing function <code>Core.Command.basic</code> or <code>Cmdliner.Cmd.v</code>. A outer layer data is usually used for argparsing one command-line case. The outer layer data is also composable and are usually used to handle cases for sub-commands. <a href="https://v3.ocaml.org/p/core/latest/doc/Core/Command/index.html#val-group"><code>Core.Command.group</code></a> takes <code>(string * Core.Command.t) list</code> and returns a <code>Core.Command.t</code>. <a href="https://erratique.ch/software/cmdliner/doc/Cmdliner/Cmd/index.html#val-group"><code>Cmdlinder.Cmd.group</code></a> takes <code>Cmdliner.Cmd.t list</code> and returns a <code>Cmdliner.Cmd.t</code>.</p>
<pre class="mermaid">---
title: Figure 1.1 - Diagram for Core.Command
---
flowchart LR
  subgraph sp [Param]
    direction LR
    P1[Param.t]--- |*| P2[Param.t] --- |*| P3[Param.t]
  end
  C1[Command.t]
  P3 --&gt; |Command.basic| C1

  subgraph sp2 [Param]
    direction LR
    Q1[Param.t]--- |*| Q2[Param.t] --- |*| Q3[Param.t]
  end
  C2[Command.t]
  Q3 --&gt; |Command.basic| C2

  subgraph sg [Command.group]
    direction LR
    C0[Command.t]
    C1 --&gt; C0
    C2 --&gt; C0
  end

  subgraph sd [Driver]
    direction LR
    Cr(Command.run)
    C1 -.-&gt; Cr
    C0 --&gt; Cr
    C2 -.-&gt; Cr
  end
</pre>
<pre class="mermaid">---
title: Figure 1.2 - Diagram for Cmdliner
---
flowchart LR
  subgraph sp [Term]
    direction LR
    P1[Term.t]--- |*| P2[Term.t] --- |*| P3[Term.t]
  end
  C1[Cmd.t]
  P3 --&gt; |Cmd.v| C1

  subgraph sp2 [Term]
    direction LR
    Q1[Term.t]--- |*| Q2[Term.t] --- |*| Q3[Term.t]
  end
  C2[Cmd.t]
  Q3 --&gt; |Cmd.v| C2

  subgraph sg [Cmd.group]
    direction LR
    C0[Cmd.v]
    C1 --&gt; C0
    C2 --&gt; C0
  end

  subgraph sd [Driver]
    direction LR
    Cr(Cmd.eval)
    C1 -.-&gt; Cr
    C0 --&gt; Cr
    C2 -.-&gt; Cr
  end
</pre>
<h2 id="how-paramt-and-termt-are-made"><a class="header" href="#how-paramt-and-termt-are-made">How <code>Param.t</code> and <code>Term.t</code> are made</a></h2>
<p>The type variable <code>'a</code> is omitted for simplicity before this section. This diagrams above show the their compositional components. <code>*</code> in <code>Param</code> and <code>Term</code> represents their possible combinations. For readers who are familiar with typeclasspedia, both of <code>'a Param.t</code> and <code>'a Term.t</code> are <em>Contravariant</em> (TODO: See post [Contravariant]). They can compose just like how parser combinator or prettyprinter does. </p>
<p>One <code>'a Param.t</code> or <code>'a Term.t</code> specifies how to parse a segment in the raw command-line string to get a value of <code>'a</code>. <code>('a * 'b) Param.t</code> or or <code>('a * 'b) Term.t</code> specifies how to get a value of <code>'a * 'b</code>.</p>
<p>Then the question how <code>Param.t</code> and <code>Term.t</code> composes becomes almost the same question that how these two libraries design the AST nodes of the command-line language.</p>
<p>A <code>Core.Command.t</code> is consists of the <em>flagged</em> parameters (or pure flags) and <em>anonymous</em> (flag-less) parameters. A <code>Cmdlinder.t</code> is consists of <em>optional arguments</em> and <em>positional arguments</em>. They are very similar correspondingly.</p>
<p>In <code>Core.Command</code>, A primitive <code>'a Param.t</code> can made up from ingridients</p>
<ol>
<li>a <code>'a Flag.t</code> wraps a <code>'a Arg_type.t</code> as <code>required</code>, <code>optional</code>, or <code>optional_with_default</code></li>
<li>a <code>'a Arg_type.t</code> on how to parse from <code>string</code> to <code>'a</code></li>
<li>a <code>'bool Flag.t</code> requires no <code>'a Arg_type.t</code>. Therefore its existence denotes a <code>true</code> or <code>false</code></li>
<li>a <code>'a Anons.t</code> which wraps a <code>'a Arg_type.t</code></li>
<li>a <code>Param.flag</code> makes a <code>'a Flag.t</code> a <code>'a Param.t</code></li>
<li>a <code>Param.anons</code> makes a <code>'a Anons.t</code> a <code>'a Param.t</code></li>
</ol>
<p>As what <code>Cmdliner.Cmd</code> is to <code>Core.Command</code>, what <code>Cmdliner.Term</code> is to <code>Command.Para</code>, <code>Cmdlinder.Arg</code> is to <code>Core.Command.Arg_type</code>.</p>
<p>In <code>Cmdlinder</code>, the ingridients to make up a primitive <code>'a Term.t</code> are:</p>
<ol>
<li><code>Arg.flag</code> makes a pure flag optional argument <code>bool Arg.t</code></li>
<li><code>'a Arg.conv</code> defines both a parser and a printer for <code>'a</code></li>
<li><code>Arg.opt</code> wraps <code>'a Arg.conv</code> an optional flagged argument <code>'a Arg.t</code>.</li>
<li><code>Arg.pos</code> wraps <code>'a Arg.conv</code> and makes a positional argument at certain index <code>'a Arg.t</code></li>
<li><code>Arg.value</code> makes a <code>'a Arg.t</code> a <code>'a Term.t</code></li>
</ol>
<p>Their diagrams are quite alike.</p>
<pre class="mermaid">---
title: Figure 2.1 - Diagram for Core.Command.Param
---
graph LR
  subgraph at [Arg_type]
    AT1[Arg_type.t]
    AT2[Arg_type.t]
  end

  subgraph fa [Flag &amp; Anons]
    CF1[Flag.t]
    CA1[Anons.t]
  end

  subgraph sp [Param]
    AT1 --&gt; |Param.required| CF1
    CF1 --&gt; |Param.flag| P1

    AT2 --&gt; |&quot;Anons.(%:)&quot;| CA1
    CA1--&gt; |Param.anons| P2

    P1[Param.t] --&gt; |*| P0[Param.t]
    P2[Param.t] --&gt; |*| P0[Param.t]
  end
  P0 --&gt; |Command.basic| C0

  subgraph sg [Command.group]
    C0[Command.t]
  end

  subgraph sd [Driver]
    Cr(Command.run)
    C0 --&gt; Cr
  end
</pre>
<pre class="mermaid">---
title: Figure 2.2 - Diagram for Cmdliner.Term
---
graph LR
  subgraph ar [Arg]
    AC1[Arg.flag]
    AC2[Arg.conv]
  end

  subgraph at [Arg.t]
    AT1[Arg.t]
    AT2[Arg.t]
  end

  subgraph sp [Term]
    direction LR
    AC1 --&gt; |Arg.opt| AT1
    AT1 --&gt; |Arg.value| P1

    AC2 --&gt; |Arg.pos| AT2
    AT2 --&gt; |Arg.value| P2

    P1[Term.t] --&gt; |*| P0[Term.t]
    P2[Term.t] --&gt; |*| P0[Term.t]
  end
  P0 --&gt; |Cmd.v| C0

  subgraph sg [Cmd.group]
    direction LR
    C0[Cmd.v]
  end

  subgraph sd [Driver]
    direction LR
    Cr(Cmd.eval)
    C0 --&gt; Cr
  end
</pre>
<h2 id="from-commandparamt-to-commandt-from-cmdlinertermt-to-cmdlinercmdt"><a class="header" href="#from-commandparamt-to-commandt-from-cmdlinertermt-to-cmdlinercmdt">From <code>Command.Param.t</code> to <code>Command.t</code>, From <code>Cmdliner.Term.t</code> to <code>Cmdliner.Cmd.t</code></a></h2>
<p>Since driver as the last step is to run the command function, the second-to-last step is to construct that function. Using the prettyprint analogy, after constructing a prettyprint for <code>'a</code>, we will then create a function to consume the prettyprint (The driver function in this analogy is to print to stdout). This step may be another ripple to understand for functional programming non-experts.</p>
<p>The basic question is, given a <code>'a Command.Param.t</code> or <code>'a Term.t</code>, users are required to provide a function to consume this <code>'a</code>. The answer is <em>fmap</em>: for <code>Core.Command</code>, it's <code>Core.Command.map</code>; for <code>Term.t</code>, it's <code>Command.Cmd.v</code>. Another fact is currently the driver function <em>almost</em> only accepts <code>unit Command.t</code> (or <code>unit Cmdliner.t</code>).</p>
<p>In <code>Core.Command</code>, <code>Command.basic</code> is the only method to achieve <em>fmap</em> from <code>'a Command.Param.t</code> to <code>unit Command.t</code>. </p>
<pre><code class="language-ocaml"># #require &quot;core&quot;;;
# open Core;;
# Command.Param.map;;
- : 'a Command.Spec.param -&gt; f:('a -&gt; 'b) -&gt; 'b Command.Spec.param = &lt;fun&gt;

# #show Command.basic;;
val basic : unit Command.basic_command

# #show Command.basic_command;;
type nonrec 'result basic_command =
    summary:string -&gt;
    ?readme:(unit -&gt; string) -&gt;
    (unit -&gt; 'result) Command.Spec.param -&gt; Command.t
</code></pre>
<p>Type <code>Command.Spec.param</code> is an alias for <code>Command.Param.t</code>. We can see the first argument and the return type of <code>Command.Param.map</code> and the second-to-last argument of <code>Command.basic_command</code>, are all <code>Command.Param.t</code>. <code>'result</code> is set to be <code>unit</code> in <code>Command.basic</code>.</p>
<p>The following two lines are equal. It's a partially applied <code>Param.map</code> from <code>string Param.t</code> to an unknown <code>~f : string -&gt; '_weak</code>:</p>
<pre><code class="language-ocaml"># Command.Param.(map (anon (&quot;filename&quot; %: string)));;
- : f:(string -&gt; '_weak1) -&gt; '_weak1 Command.Spec.param = &lt;fun&gt;

# Command.(let s : string Param.Arg_type.t = Param.string in let a = Anons.(%:) &quot;filename&quot; s in Param.map (Param.anon a));;
- : f:(string -&gt; '_weak2) -&gt; '_weak2 Command.Spec.param = &lt;fun&gt;
</code></pre>
<p>Now we can figure out a usage for <code>Command.basic</code>. And this <code>Command.t</code> is safe to use in the driver function <code>Command.run</code>.</p>
<pre><code class="language-ocaml"># Command.basic ~summary:&quot;fairy file&quot; Command.Param.(map (anon (&quot;filename&quot; %: string)) ~f:(fun file () -&gt; ignore file));;
- : Command.t = &lt;abstr&gt;
</code></pre>
<p>The observation here is <code>Command.basic</code> requires an argument of type <code>(unit -&gt; unit) Command.Spec.param</code>. The user code is usually made by <code>Param.map a_b_c_param ~f:(fun a b c () -&gt; ... ()) : (unit -&gt; unit) Command.Spec.param</code>. The parsed result is passed before the last <code>unit</code> argument.</p>
<p>The last step to make it familiar to RWO readers is to use <code>let%map_open</code> instead of <code>Param.map</code>. The code is equivalent to the above one:</p>
<pre><code class="language-ocaml"># #require &quot;ppx_jane&quot;;;
# Command.basic ~summary:&quot;fairy file&quot; (let%map_open.Command file = (anon (&quot;filename&quot; %: string)) in fun () -&gt; ignore file);;
- : Command.t = &lt;abstr&gt;
</code></pre>
<p>TODO: fmap for Cmdliner</p>
<p>TODO: examples.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../internals/polymorphic-compare.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../core/maps-and-hashtables.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../internals/polymorphic-compare.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../core/maps-and-hashtables.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" charset="utf-8"></script>
        <script src="../mark.min.js" charset="utf-8"></script>
        <script src="../searcher.js" charset="utf-8"></script>

        <script src="../clipboard.min.js" charset="utf-8"></script>
        <script src="../highlight.js" charset="utf-8"></script>
        <script src="../book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script src="../asset/mermaid.min.js"></script>
        <script src="../asset/mermaid-init.js"></script>


    </body>
</html>
