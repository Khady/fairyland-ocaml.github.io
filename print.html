<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fairyland OCaml</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="SUMMARY.html">Summary</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded affix "><a href="libraries/hashcons.html">Using Hashcons</a></li><li class="chapter-item expanded affix "><a href="core/container-elements.html">What are [@@deriving compare, sexp_of, hash] for?</a></li><li class="chapter-item expanded affix "><a href="core/maps-and-hashtables.html">Using Data Collections in Core</a></li><li class="chapter-item expanded affix "><div>Fix</div></li><li class="chapter-item expanded affix "><div>Command-line</div></li><li class="chapter-item expanded affix "><div>Profiling</div></li><li class="chapter-item expanded affix "><div>Deriving print</div></li><li class="chapter-item expanded affix "><div>Understanding type format6</div></li><li class="chapter-item expanded affix "><div>Understanding module Format</div></li><li class="chapter-item expanded affix "><div>Contravariant</div></li><li class="chapter-item expanded affix "><div>Typeclassopedia</div></li><li class="chapter-item expanded affix "><div>OCaml source reading</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fairyland OCaml</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p><a href="SUMMARY.html">Summary</a> This Page</p>
<p><a href="preface.html">Preface</a> Why Fairyland OCaml</p>
<h2 id="section-library-gems"><a class="header" href="#section-library-gems">Section: Library Gems</a></h2>
<p>Good libraries deserve more explanaion.</p>
<p><a href="libraries/hashcons.html">Using <code>Hashcons</code></a></p>
<h2 id="section-using-core"><a class="header" href="#section-using-core">Section: Using <code>Core</code></a></h2>
<p>More comprehensive discussion after RWO.</p>
<p><a href="core/container-elements.html">What are [@@deriving compare, sexp_of, hash] for?</a></p>
<h2 id="-below-is-under-construction-"><a class="header" href="#-below-is-under-construction-">ðŸš§ðŸš§ <strong>Below is under construction</strong> ðŸš§ðŸš§</a></h2>
<p><a href="core/maps-and-hashtables.html">Using Data Collections in <code>Core</code></a></p>
<p><a href="">Fix</a> (topics/fix.md)</p>
<p><a href="">Command-line</a> (topics/command-line.md)</p>
<p><a href="">Profiling</a> (topics/profiling.md)</p>
<h2 id="section-ocaml-internals"><a class="header" href="#section-ocaml-internals">Section: OCaml Internals</a></h2>
<p><a href="">Deriving print</a> (internals/deriving-print.md)</p>
<p><a href="">Understanding type <code>format6</code></a> (internals/type-format6.md)</p>
<p><a href="">Understanding module <code>Format</code></a> (internals/module-format.md)</p>
<h2 id="section-concepts"><a class="header" href="#section-concepts">Section: Concepts</a></h2>
<p><a href="">Contravariant</a> (concepts/contravariant.md)</p>
<p><a href="">Typeclassopedia</a> (concepts/typeclassopedia.md)</p>
<h2 id="section-code-reading"><a class="header" href="#section-code-reading">Section: Code Reading</a></h2>
<p><a href="">OCaml source reading</a> (reading/ocaml-source-reading.md)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>Fairyland OCaml is a blog by <a href="https://www.prover.me/">Shiwei Weng</a> to write my OCaml experience. I used to share OCaml snippet and understanding in our research group <a href="https://pl.cs.jhu.edu/">JHU PL Lab</a>. I decided to port them here. The intuition often comes from my learning and research experience as well as fantastic students from two <a href="https://pl.cs.jhu.edu/fpse/">functional</a> <a href="https://pl.cs.jhu.edu/pl/">programming</a> courses at JHU.</p>
<p>The blog name is obviously from <a href="https://dev.realworldocaml.org/">Real World OCaml</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-hashcons"><a class="header" href="#using-hashcons">Using <code>Hashcons</code></a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p><em>Aside</em>. Data, value, object, component in this post means the same thing but from different perspectives.</p>
<p><em>Folklore</em>. Hash-consing, as the name may suggest, is a hash value cons-ed (appended) after the immutable data (hash key). The immediate benefit is to reuse the hash value for the unchanged data. When used in recursive datatypes, the hash value of a data can be computed from the new payload part and the recursive part whose hash value is already cons-ed.</p>
<p><em>One-step further</em>. It's obvious hash-consing is straightforward for immutable data. However, with immutable data, more aggresive designs can be made. Hash-consing libraries in real-world usually coincide with <a href="https://en.wikipedia.org/wiki/Flyweight_pattern">Flyweight pattern</a>. They have the same targets:</p>
<ol>
<li>Encapsulate the object creation so that any distinct object is created just once.</li>
<li>Generate and save a <strong>unique id</strong> to identify distinct objects.</li>
<li>Save the hash value in the objects and choose a hash function that is aware of the saved hash values for its recursive components.</li>
</ol>
<h2 id="some-concept-or-implementation-details"><a class="header" href="#some-concept-or-implementation-details">Some Concept (or Implementation) Details</a></h2>
<p><em>Hash functions</em>. With a unique id cons-ed, the datatype can provide a new <code>equal</code> function and a new <code>hash</code> function based on this id. In whole scenarios, three <code>hash</code> functions can be used.</p>
<ol>
<li>Global <code>hash</code>. Language provide e.g. <code>Hashtbl.hash</code>. It's used internally for convenience.</li>
<li>Data's <code>hash</code>. The hash function for your hash-consed data provided by users.</li>
<li>Hash-consing library <code>hash</code>. The hash function for your hash-consed data provided by the library.</li>
</ol>
<p>The existence and difference between <strong>2</strong> and <strong>3</strong> is not so clear depending on the library design. However, the ultimate target is to provide a better <strong>2</strong> with or without <strong>3</strong> than the old structural <code>hash</code>.</p>
<p><em>Weak references</em>. Hash-consing library needs to provide an internal store to save the unique objects. This storage can be a <em>weak</em> array or a <em>weak</em> hash table. The internal storage should be <em>weak</em> because it should not prevent the garbage collection if any elements are not used outside.</p>
<p><em>Hash collision</em>. Hash collision and hash resize is handled during the process to generate the unique id with the internal storage. The data's <code>equal</code> and data's <code>hash</code> function will be used. Data's <code>hash</code> collision outside of the internal storage is not concerned here.</p>
<p><em>Structural equality</em>. A natural consequence of unique objects and ids is the structural equality check between two values can be replaced by physical equality. Refresh: structural equality checks whether two values per-component of their structures. Physical equality checks whether two values are at the same memory address. If all the objects is created inside the hash consing library, strutural equality can be replaced by phisical equality. <code>=</code> in OCaml approximates a structural equality check. <code>==</code> in OCaml is phisical equality check.</p>
<h2 id="reading-library-code"><a class="header" href="#reading-library-code">Reading library code</a></h2>
<p>Now we are ready to look closely into two OCaml libraries <code>backtracking/ocaml-hashcons</code> (<code>hashcons</code> on opam) and <code>fpottier/fix</code> with <code>Fix.HashCons</code> (<code>fix</code> on opam).</p>
<h3 id="backtrackingocaml-hashcons"><a class="header" href="#backtrackingocaml-hashcons"><code>backtracking/ocaml-hashcons</code></a></h3>
<p>The repo is <a href="https://github.com/backtracking/ocaml-hashcons">backtracking/ocaml-hashcons</a>.</p>
<p><a href="https://github.com/backtracking/ocaml-hashcons/blob/master/hashcons.mli"><code>hashcons.mli</code></a> defines the type:</p>
<pre><code class="language-ocaml">type +'a hash_consed = private {
  hkey: int;
  tag : int;
  node: 'a;
}
</code></pre>
<p>It's a bit subtle since <code>hkey</code> is computed <em>value</em> from the user-provided <code>H.hash</code> on the data before adding to the internal store. <code>tag</code> is the unique id which is either old from a previous object or new if added. <code>node</code> is the data before hash-consed.</p>
<p>The following code snippets are from <a href="https://github.com/backtracking/ocaml-hashcons/blob/master/test.ml"><code>test.ml</code></a> :</p>
<pre><code class="language-ocaml">open Hashcons

(* a quick demo of Hashcons using lambda-terms *)

type node =
  | Var of string
  | App of term * term
  | Lam of string * term
and term = node hash_consed

(* the key here is to make a O(1) equal and hash functions, making use of the fact that sub-terms are already hash-consed and thus we can 
   1. use == on sub-terms to implement equal
   2. use .tag from sub-terms to implement hash 
   *)
module X = struct
  type t = node
  let equal t1 t2 = match t1, t2 with
    | Var s1, Var s2 -&gt; s1 = s2
    | App (t11, t12), App (t21, t22) -&gt; t11 == t21 &amp;&amp; t12 == t22
    | Lam (s1, t1), Lam (s2, t2) -&gt; s1 = s2 &amp;&amp; t1 == t2
    | _ -&gt; false
  let hash = function
    | Var s -&gt; Hashtbl.hash s
    | App (t1, t2) -&gt; t1.tag * 19 + t2.tag
    | Lam (s, t) -&gt; Hashtbl.hash s * 19 + t.tag
end
module H = Make(X)

let ht = H.create 17
let var s = H.hashcons ht (Var s)
let app t1 t2 = H.hashcons ht (App (t1,t2))
let lam s t = H.hashcons ht (Lam (s,t))

let x = var &quot;x&quot;
let delta = lam &quot;x&quot; (app x x)
let omega = app delta delta

let () = assert (var &quot;x&quot; == x)
let () = assert (app x x == app x x)
</code></pre>
<p><code>X.hash</code> is the data's <code>hash</code>. Global <code>hash</code> is used both in <code>X.hash</code> inside of <a href="https://github.com/backtracking/ocaml-hashcons/blob/872594154dd263334a8f79822f99f1065832d383/hashcons.ml#L110"><code>H.hashcons</code></a>. <code>X.equal</code> uses physical equality for objects. <code>X.hash</code> also uses the unique ids for components. The last two <code>assert</code>s check the objects created at different application shares the same memory addresses.</p>
<p>Module <code>Hashcons</code> also provides <code>Hset</code> and <code>Hmap</code>. They're external containers which is aware of your hash-consed data. Don't confuse them with the internal storage, which is also a hash-based container.</p>
<h3 id="fpottierfix"><a class="header" href="#fpottierfix"><code>fpottier/fix</code></a></h3>
<p>The repo is <a href="https://gitlab.inria.fr/fpottier/fix">fpottier/fix</a>.</p>
<p><code>Fix.HashCons</code>(<a href="https://gitlab.inria.fr/fpottier/fix/-/blob/master/src/HashCons.ml">ml</a>,<a href="https://gitlab.inria.fr/fpottier/fix/-/blob/master/src/HashCons.mli">mli</a>) looks very lightweighted because the internal storage is achieved by another module <code>Fix.MEMOIZER</code>. </p>
<pre><code class="language-ocaml">type 'data cell =
  { id: int; data: 'data }
</code></pre>
<p><code>id</code> is the unique id while <code>data</code> is your datatype to hash-cons. The another difference worth mentioning is with <code>backtracking/ocaml-hashcons</code> the user is in change of the objects pool getting from <code>H.create</code> while with <code>Fix.HashCons</code> the pool is shared. It's explained in <a href="https://gitlab.inria.fr/fpottier/fix/-/blob/master/src/HashCons.ml?ref_type=heads#L19">HashCons.ml</a>.</p>
<pre><code class="language-ocaml">(* M : MEMOIZER *)
let make =
    M.memoize (fun data -&gt; { id = gensym(); data })
</code></pre>
<p><code>MEMOIZER</code> is a module relying on the user-provide <code>Map.S</code> which contains <code>find</code> and <code>add</code>. No data's <code>hash</code> is required, but making <code>MEMOIZER</code> requires a <code>HashedType</code>. The result module of <code>HashCons.Make</code> provides a <code>hash</code> which relies on the unique id.</p>
<p>The demo code <a href="https://gitlab.inria.fr/fpottier/fix/-/blob/master/demos/hco/HashConsDemo.ml">demos/hco
HashConsDemo.ml</a> is challenging to read if one is not aware of these <code>hash</code> functions in use.</p>
<pre><code class="language-ocaml">open Fix

module MySkeleton = struct
  type 'a t =
    | Leaf
    | Node of int * 'a * 'a

  let equal equal sk1 sk2 =
    match sk1, sk2 with
    | Leaf, Leaf -&gt;
        true
    | Node (x1, l1, r1), Node (x2, l2, r2) -&gt;
        x1 = x2 &amp;&amp; equal l1 l2 &amp;&amp; equal r1 r2
    | Node _, Leaf
    | Leaf, Node _ -&gt;
        false

  let hash hash sk =
    match sk with
    | Leaf -&gt;
        0
    | Node (x, l, r) -&gt;
        x + hash l + hash r
end

type tree =
  skeleton HashCons.cell

and skeleton =
  S of tree MySkeleton.t [@@unboxed]

module M =
  HashCons.ForHashedTypeWeak(struct
    type t = skeleton
    let equal (S sk1) (S sk2) =
      MySkeleton.equal HashCons.equal sk1 sk2
    let hash (S sk) =
      MySkeleton.hash HashCons.hash sk
  end)

let leaf () : tree =
  M.make (S MySkeleton.Leaf)

let node x l r : tree =
  M.make (S (MySkeleton.Node (x, l, r)))

let example() =
  node 0
    (leaf())
    (leaf())

let () =
  assert (example() == example());
  Printf.printf &quot;Size of example tree is %d.\n&quot; (size (example()));
  print_endline &quot;Success.&quot;
</code></pre>
<p><code>MySkeleton</code> provides <code>equal</code> and <code>hash</code>, which require another <code>equal</code> and <code>hash</code> as arguments respectively. The hash-consing aware <code>equal</code> and <code>hash</code> is provided in <code>HashCons.ForHashedTypeWeak</code>. The resulting code shares the same motivation as the previous demo.</p>
<h2 id="summary-and-questions-to-do"><a class="header" href="#summary-and-questions-to-do">Summary and Questions (To-do)</a></h2>
<p>I am short on time to polish the post and complete all my to-do now. My motivation is the fixed point computation runs very slow on several test cases, and the profiling results show it's doing too much repeated structural hashing. The post mainly shares how to understand hash-consing libraries. <em>If I may</em>, I will rename both <code>hash consing</code> or <code>flyweight</code> to <code>with_unique</code> or <code>with_uid</code>.</p>
<p>Besides these two OCaml libraries, I also refer to <a href="https://en.wikipedia.org/wiki/Hash_consing">wiki/Hashconing</a> and papers</p>
<ul>
<li>Sylvain Conchon and Jean-Christophe FilliÃ¢tre. Type-Safe Modular Hash-Consing. In ACM SIGPLAN Workshop on ML, Portland, Oregon, September 2006.</li>
<li>Implementing and reasoning about hash-consed data structures in Coq</li>
</ul>
<p>How to bring hash-consing to <code>Core</code> is my immediate problem.</p>
<p>Furthermore, as string intern is widely used for many languages, why is hash-consing not the default implementation inside OCaml compilers?</p>
<p>The functions on the raw types need to be reimplemented with the hash cons-ed type with just tedious fmap. Is it another case for the <em>Expression Problem</em> or <em>Open Recursion</em>?</p>
<p>I am also interested in the implementation of <a href="https://github.com/camlp5/pa_ppx_hashcons">camlp5/pa_ppx_hashcons</a> and <a href="https://coq.inria.fr/doc/master/api/coq-core/Hashcons/index.html">coq-core/Hashcons</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-are-deriving-compare-sexp_of-hash-for"><a class="header" href="#what-are-deriving-compare-sexp_of-hash-for">What are [@@deriving compare, sexp_of, hash] for?</a></h1>
<p>Real World OCaml has a dedicated chapter <a href="https://dev.realworldocaml.org/maps-and-hashtables.html">Maps and Hash Tables</a>. It's an excellent tutorial to start with data containers in Jane Street's <code>core</code> (or <code>Base</code>), an alternative to the OCaml standard library <code>stdlib</code>. For both <code>core</code> and <code>stdlib</code>, elements need to provide required <em>functions</em> to be put into containers. The tutorial gives examples of elements with hand-written functions and derived functions.</p>
<!-- $MDX file=../../src-ocaml/elements.ml,part=book1 -->
<pre><code class="language-ocaml">  open Core

  module Book = struct
    module T = struct
      type t = { title : string; isbn : string }

      let compare t1 t2 =
        let cmp_title = String.compare t1.title t2.title in
        if cmp_title &lt;&gt; 0 then cmp_title else String.compare t1.isbn t2.isbn

      let sexp_of_t t : Sexp.t = List [ Atom t.title; Atom t.isbn ]
    end

    include T
    include Comparator.Make (T)
  end
</code></pre>
<!-- $MDX file=../../src-ocaml/elements.ml,part=book2 -->
<pre><code class="language-ocaml">  open Core

  module Book = struct
    module T = struct
      type t = { title : string; isbn : string } [@@deriving compare, sexp_of]
    end

    include T
    include Comparator.Make (T)
  end
</code></pre>
<p>Let's focus in what's inside of <code>T</code>. In this post, we will figure out one question:</p>
<p>What are <code>[@@deriving compare, sexp_of, hash]</code> for, as the post title askes?</p>
<p>We will answer this question from the user-code side, and left the explanation from the library-code side for the future.</p>
<h2 id="deriving-functions"><a class="header" href="#deriving-functions">Deriving Functions</a></h2>
<p>These ppx deriver are <a href="https://github.com/janestreet/ppx_compare">janestreet/ppx_compare</a> for <code>equal</code> and <code>compare</code>, <a href="https://github.com/janestreet/ppx_sexp_conv">janestreet/ppx_sexp_conv</a> for <code>sexp_of</code> and <code>of_sexp</code>, and <a href="https://github.com/janestreet/ppx_hash">janestreet/ppx_hash</a> for <code>hash</code> and <code>hash_fold</code>.</p>
<p>A quick way to inspect the deriving result is to change <code>[@@deriving &lt;ppx&gt;]</code> to <code>[@@deriving_inline &lt;ppx&gt;] [@@@end]</code> so there we can read the generated code between tags.</p>
<p>The idea of all these function deriver are type-based structural traversal. Don't be disturbed by the variable names in the generated code. </p>
<!-- $MDX file=../../src-ocaml/elements.ml,part=pair_inline_equal -->
<pre><code class="language-ocaml">type foo1 = P1 of int * string [@@deriving_inline equal]

let _ = fun (_ : foo1) -&gt; ()
let equal_foo1 =
  (fun a__008_ -&gt;
     fun b__009_ -&gt;
       if Stdlib.(==) a__008_ b__009_
       then true
       else
         (match (a__008_, b__009_) with
          | (P1 (_a__010_, _a__012_), P1 (_b__011_, _b__013_)) -&gt;
              Stdlib.(&amp;&amp;) (equal_int _a__010_ _b__011_)
                (equal_string _a__012_ _b__013_)) : foo1 -&gt; foo1 -&gt; bool)
let _ = equal_foo1
[@@@end]
</code></pre>
<p><code>equal</code> is straightforward. Two values are equal if they are physically equal i.e. at the same memory address. Otherwises, they need to be equal piecewise-ly. <code>Core</code> doesn't shadow OCaml vanilla standard library <code>Stdlib</code>.</p>
<!-- $MDX file=../../src-ocaml/elements.ml,part=pair_inline_compare -->
<pre><code class="language-ocaml">type foo2 = P2 of int * string [@@deriving_inline compare]

let _ = fun (_ : foo2) -&gt; ()
let compare_foo2 =
  (fun a__014_ -&gt;
     fun b__015_ -&gt;
       if Stdlib.(==) a__014_ b__015_
       then 0
       else
         (match (a__014_, b__015_) with
          | (P2 (_a__016_, _a__018_), P2 (_b__017_, _b__019_)) -&gt;
              (match compare_int _a__016_ _b__017_ with
               | 0 -&gt; compare_string _a__018_ _b__019_
               | n -&gt; n)) : foo2 -&gt; foo2 -&gt; int)
let _ = compare_foo2
[@@@end]
</code></pre>
<p><code>compare</code> is similar to <code>equal</code>. <code>Stdlib.compare : 'a -&gt; 'a -&gt; int</code> the polymorphic compare is not used in <code>Core</code>, however, the convertion should be observed: <code>compare x y</code> returns 0 if x is equal to y, a negative integer if x is less than y, and a positive integer if x is greater than y.</p>
<!-- $MDX file=../../src-ocaml/elements.ml,part=pair_inline_sexp -->
<pre><code class="language-ocaml">type foo3 = P3 of int * string [@@deriving_inline sexp]

let _ = fun (_ : foo3) -&gt; ()
let foo3_of_sexp =
  (let error_source__022_ = &quot;src-ocaml/elements.ml.foo3&quot; in
   function
   | Sexplib0.Sexp.List ((Sexplib0.Sexp.Atom
       (&quot;p3&quot; | &quot;P3&quot; as _tag__025_))::sexp_args__026_) as _sexp__024_ -&gt;
       (match sexp_args__026_ with
        | arg0__027_::arg1__028_::[] -&gt;
            let res0__029_ = int_of_sexp arg0__027_
            and res1__030_ = string_of_sexp arg1__028_ in
            P3 (res0__029_, res1__030_)
        | _ -&gt;
            Sexplib0.Sexp_conv_error.stag_incorrect_n_args error_source__022_
              _tag__025_ _sexp__024_)
   | Sexplib0.Sexp.Atom (&quot;p3&quot; | &quot;P3&quot;) as sexp__023_ -&gt;
       Sexplib0.Sexp_conv_error.stag_takes_args error_source__022_ sexp__023_
   | Sexplib0.Sexp.List ((Sexplib0.Sexp.List _)::_) as sexp__021_ -&gt;
       Sexplib0.Sexp_conv_error.nested_list_invalid_sum error_source__022_
         sexp__021_
   | Sexplib0.Sexp.List [] as sexp__021_ -&gt;
       Sexplib0.Sexp_conv_error.empty_list_invalid_sum error_source__022_
         sexp__021_
   | sexp__021_ -&gt;
       Sexplib0.Sexp_conv_error.unexpected_stag error_source__022_ sexp__021_ :
  Sexplib0.Sexp.t -&gt; foo3)
let _ = foo3_of_sexp
let sexp_of_foo3 =
  (fun (P3 (arg0__031_, arg1__032_)) -&gt;
     let res0__033_ = sexp_of_int arg0__031_
     and res1__034_ = sexp_of_string arg1__032_ in
     Sexplib0.Sexp.List [Sexplib0.Sexp.Atom &quot;P3&quot;; res0__033_; res1__034_] :
  foo3 -&gt; Sexplib0.Sexp.t)
let _ = sexp_of_foo3

[@@@end]
</code></pre>
<p><code>sexp_of</code> and <code>of_sexp</code> are for serialization and deserialization. More details are at RWO Chapter <a href="https://dev.realworldocaml.org/data-serialization.html">Data Serialization with S-Expressions</a>.</p>
<!-- $MDX file=../../src-ocaml/elements.ml,part=pair_inline_hash -->
<pre><code class="language-ocaml">type foo4 = P4 of int * string [@@deriving_inline hash]

let _ = fun (_ : foo4) -&gt; ()

let (hash_fold_foo4 :
      Ppx_hash_lib.Std.Hash.state -&gt; foo4 -&gt; Ppx_hash_lib.Std.Hash.state) =
  (fun hsv arg -&gt;
     match arg with
     | P4 (_a0, _a1) -&gt;
         let hsv = hsv in
         let hsv =
           let hsv = hsv in
           hash_fold_int hsv _a0
         in
         hash_fold_string hsv _a1
    : Ppx_hash_lib.Std.Hash.state -&gt; foo4 -&gt; Ppx_hash_lib.Std.Hash.state)

let _ = hash_fold_foo4

let (hash_foo4 : foo4 -&gt; Ppx_hash_lib.Std.Hash.hash_value) =
  let func arg =
    Ppx_hash_lib.Std.Hash.get_hash_value
      (let hsv = Ppx_hash_lib.Std.Hash.create () in
       hash_fold_foo4 hsv arg)
  in
  fun x -&gt; func x

let _ = hash_foo4

[@@@end]
</code></pre>
<p>Here are the most <em>complex</em> functions. <code>hash_fold</code> is a state-passing function to perform the hashing payload. <code>hash</code> wraps <code>hash_fold</code> by providing an initial hash state via <code>Hash.create ()</code> and converting the hash result to <code>int</code> via <code>Hash.get_hash_value</code>.
It implies if we need a cutsom hash function, implementing <code>hash_fold</code> to perform hashing and providing the same wrapping <code>hash</code> here.</p>
<p>Further explanation can be found at doc for <a href="https://v3.ocaml.org/p/base/latest/doc/Base/Hasher/module-type-S/index.html">Base.Hasher.S</a> and the <a href="https://github.com/janestreet/ppx_hash/blob/master/doc/design.notes">ppx_hash/design_doc</a>. In short, <code>hash_fold</code> should take care of not only the values in the structure not also the structure itself, to avoid easily hash collision.</p>
<p>It becomes tricky when a <code>Core</code>-container is used as an element and this element is intended to be used in a container requiring hash, e.g. putting this <code>Int_set_as_element</code> in a <code>Hash_set</code>.</p>
<!-- $MDX file=../../src-ocaml/elements.ml,part=int_set_as_element -->
<pre><code class="language-ocaml">module Int_set_as_element = struct
  module T = struct
    type t = Set.M(Int).t [@@deriving_inline compare, sexp_of, hash]

    let _ = fun (_ : t) -&gt; ()

    let compare =
      (fun a__035_ b__036_ -&gt; Set.compare_m__t (module Int) a__035_ b__036_
        : t -&gt; t -&gt; int)

    let _ = compare

    let sexp_of_t =
      (fun x__037_ -&gt; Set.sexp_of_m__t (module Int) x__037_
        : t -&gt; Sexplib0.Sexp.t)

    let _ = sexp_of_t

    let (hash_fold_t :
          Ppx_hash_lib.Std.Hash.state -&gt; t -&gt; Ppx_hash_lib.Std.Hash.state) =
     fun hsv arg -&gt; Set.hash_fold_m__t (module Int) hsv arg

    and (hash : t -&gt; Ppx_hash_lib.Std.Hash.hash_value) =
      let func = Set.hash_m__t (module Int) in
      fun x -&gt; func x

    let _ = hash_fold_t
    and _ = hash

    [@@@end]
  end

  include T
  include Comparator.Make (T)
end

let _ = Set.empty (module Int_set_as_element)
let _ = Hash_set.create (module Int_set_as_element)
</code></pre>
<p>Both <code>Set.hash_m__t</code> and <code>Set.hash_fold_m__t</code> requires a first-class module implementing <code>Hasher.S</code> (which requires <code>hash_fold_t</code>). In this example, the module is <code>Int</code>. <code>Int</code> is a build-in module containing <code>hash</code> and <code>hash_fold</code>. If this is <code>Your_data</code> rather than <code>Int</code>, the generated code above for <code>Set.M(Your_data).t</code> will have <code>Set.hash_m__t (module Your_data)</code> and <code>Set.hash_fold_m__t (module Your_data)</code>. Therefore, <code>Your_data</code> have to provide <code>hash</code> and <code>hash_fold</code> functions.</p>
<p>This can explain why <code>Base.Hash_set.Key</code> contains <code>hash</code> and no <code>hash_fold</code>, but we still need <code>hash_fold</code> even it may not be immediately used.</p>
<p>p.s. I don't claim this design is good.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map-set-and-hashtables"><a class="header" href="#map-set-and-hashtables">Map, Set and Hashtables</a></h1>
<p>What are exact functions required for distinct data containers?</p>
<p>Afterr all, what collections are in <code>Base</code> and <code>Core</code>?</p>
<p>| Base                        | Core | Stdlib                   | kind      | requiring                | comment                                                                        |
| --------------------------- | ---- | ------------------------ | --------- | ------------------------ | ------------------------------------------------------------------------------ |
| <code>Applicative</code>               |      | /                        | functor   |                          |                                                                                |
| <code>Array</code>                     |      | <code>Array</code>                  | std       |                          |                                                                                |
| <code>Avltree</code>                   |      | /                        | low-level |                          |                                                                                |
| <code>Backtrace</code>                 |      | <code>Printexc.raw_backtrace</code> | system    |                          |                                                                                |
| <code>Binary_search</code>             |      | /                        | interface |                          |                                                                                |
| <code>Binary_searchable</code>         |      | /                        | functor   |                          |                                                                                |
| <code>Blit</code>                      |      | /                        | std       |                          | bit-block transfer                                                             |
| <code>Bool</code>                      |      | <code>Bool</code>                   | std       |                          |                                                                                |
| <code>Buffer</code>                    |      | <code>Buffer</code>                 | std       |                          |                                                                                |
| <code>Bytes</code>                     |      | <code>Bytes</code>                  | std       |                          |                                                                                |
| <code>Char</code>                      |      | <code>Char</code>                   | std       |                          |                                                                                |
| <code>Comparable</code>                |      | /                        | functor   |                          |                                                                                |
| <code>Comparator</code>                |      | /                        | functor   |                          |                                                                                |
| <code>Comparisons</code>               |      | /                        | interface |                          |                                                                                |
| <code>Container</code>                 |      | /                        | functor   |                          |                                                                                |
| <code>Either</code>                    |      | <code>Either</code>                 | std       |                          |                                                                                |
| <code>Equal</code>                     |      | /                        | interface |                          |                                                                                |
| <code>Error</code>                     |      | /                        | std       |                          |                                                                                |
| <code>Exn</code>                       |      | <code>exn</code>                    | std       |                          |                                                                                |
| <code>Export</code>                    |      | /                        | wrap      |                          | undoc                                                                          |
| <code>Field</code>                     |      | /                        | std       |                          |                                                                                |
| <code>Float</code>                     |      | <code>Float</code>                  | std       |                          |                                                                                |
| <code>Floatable</code>                 |      | /                        | interface |                          |                                                                                |
| <code>Fn</code>                        |      | /                        | std       |                          |                                                                                |
| <code>Formatter</code>                 |      | <code>Formatter</code>              | std       |                          |                                                                                |
| <code>Hash</code>                      |      | /                        | std       |                          | hash primitives                                                                |
| <code>Hash_set</code>                  |      | /                        | container | <code>compare, sexp_of, hash</code> |                                                                                |
| <code>Hashable</code>                  |      | /                        | interface |                          | module trait                                                                   |
| <code>Hasher</code>                    |      | /                        | interface |                          | just <code>t</code> and <code>hash_fold_t</code>                                                     |
| <code>Hashtbl</code>                   |      | <code>Hashtbl</code>                | container | <code>compare, sexp_of, hash</code> |                                                                                |
| <code>Identifiable</code>              |      | /                        | functor   |                          |                                                                                |
| <code>Indexed_container</code>         |      | /                        | interface |                          |                                                                                |
| <code>Info</code>                      |      | /                        | std       |                          |                                                                                |
| <code>Int</code>                       |      | <code>Int</code>                    | std       |                          |                                                                                |
| <code>Int32</code>                     |      | <code>Int32</code>                  | std       |                          |                                                                                |
| <code>Int63</code>                     |      | /                        | std       |                          |                                                                                |
| <code>Int64</code>                     |      | <code>Int64</code>                  | std       |                          |                                                                                |
| <code>Int_conversions</code>           |      | /                        | std       |                          |                                                                                |
| <code>Intable</code>                   |      | /                        | interface |                          |                                                                                |
| <code>Int_math</code>                  |      | /                        | functor   |                          |                                                                                |
| <code>Invariant</code>                 |      | /                        | interface |                          |                                                                                |
| <code>Lazy</code>                      |      | <code>Lazy</code>                   | std       |                          |                                                                                |
| <code>Linked_queue</code>              |      | <code>Queue </code>                 | container |                          |                                                                                |
| <code>List</code>                      |      | <code>List</code>                   | container |                          |                                                                                |
| <code>Map</code>                       |      | <code>Map</code>                    | std       | <code>compare, sexp_of</code>       | balanced binary tree over a totally-ordered domain                             |
| <code>Maybe_bound</code>               |      | /                        | std       |                          |                                                                                |
| <code>Monad</code>                     |      | /                        | functor   |                          |                                                                                |
| <code>Nativeint</code>                 |      | /                        | std       |                          |                                                                                |
| <code>Nothing</code>                   |      | /                        | std       |                          |                                                                                |
| <code>Option</code>                    |      | <code>Option</code>                 | std       |                          |                                                                                |
| <code>Option_array</code>              |      | /                        | std       |                          |                                                                                |
| <code>Or_error</code>                  |      | /                        | std       |                          | a specialization of the <code>Result</code> type                                          |
| <code>Ordered_collection_common</code> |      | /                        | trait     |                          |                                                                                |
| <code>Ordering</code>                  |      | /                        | std       |                          |                                                                                |
| <code>Poly</code>                      |      | <code>Stdlib</code>                 | std       |                          |                                                                                |
| <code>Pretty_printer</code>            |      | /                        | std       |                          | for use in toplevels                                                           |
| <code>Printf</code>                    |      | <code>Printf</code>                 | std       |                          |                                                                                |
| <code>Queue</code>                     |      | <code>Queue</code>                  | std       |                          | A queue implemented with an array                                              |
| <code>Random</code>                    |      | <code>Random</code>                 | std       |                          |                                                                                |
| <code>Ref</code>                       |      | <code>'a ref</code>                 | std       |                          |                                                                                |
| <code>Result</code>                    |      | <code>Result</code>                 | std       |                          |                                                                                |
| <code>Sequence</code>                  |      | <code>Seq</code>                    | std       |                          |                                                                                |
| <code>Set</code>                       |      | <code>Set</code>                    | std       |                          | Sets based on <code>Comparator.S</code>                                                   |
| <code>Sexp</code>                      |      | /                        | std       |                          |                                                                                |
| <code>Sexpable</code>                  |      | /                        | functor   |                          |                                                                                |
| <code>Sign</code>                      |      | /                        | std       |                          |                                                                                |
| <code>Sign_or_nan</code>               |      | /                        | std       |                          |                                                                                |
| <code>Source_code_position</code>      |      | /                        | std       |                          |                                                                                |
| <code>Stack</code>                     |      | <code>Stack</code>                  | std       |                          |                                                                                |
| <code>Staged</code>                    |      | /                        | std       |                          |                                                                                |
| <code>String</code>                    |      | <code>String</code>                 | std       |                          |                                                                                |
| <code>Stringable</code>                |      | /                        | interface |                          |                                                                                |
| <code>Sys</code>                       |      | <code>Sys</code>                    | std       |                          |                                                                                |
| <code>T</code>                         |      | /                        | interface |                          |                                                                                |
| <code>Type_equal</code>                |      | /                        | std       |                          | to represent type equalities that the type checker otherwise would not know    |
| <code>Uniform_array</code>             |      | /                        | std       |                          | guaranteed that the representation array is not tagged with <code>Double_array_tag</code> |
| <code>Unit</code>                      |      | <code>unit</code>                   | std       |                          |                                                                                |
| <code>Uchar</code>                     |      | /                        | std       |                          |                                                                                |
| <code>Variant</code>                   |      | /                        | std       |                          | used in <code>[@@deriving variants]</code>                                                |
| <code>With_return</code>               |      | /                        | std       |                          |                                                                                |
| <code>Word_size</code>                 |      | /                        | std       |                          |                                                                                |
| ``                          |      | /                        | std       |                          |                                                                                |</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>

        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script src="asset/mermaid.min.js"></script>
        <script src="asset/mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
